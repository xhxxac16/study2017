第五章 Strings and Regular Expressions 字符串和正则表达式

String Concatenation 字符串连接
字符串连接表现出惊人的性能紧张。通常一个任务通过一个循环，向字符串末尾不断地添加内容，来创建一个字符串（例如，创建一个HTML 表或者一个XML 文档），但此类处理在一些浏览器上表现糟糕而遭人痛恨。

当连接少量字符串时，所有这些函数都很快，临时使用的话，可选择最熟悉的使用。当合并字符串的长度和数量增加之后，有些函数开始显示出自己的威力。


Plus (+) and Plus-Equals (+=) Operators 加和加等于操作
这些操作符提供了连接字符串的最简单方法，事实上，除IE7 和它之前的所有现代浏览器都对此优化得很好，所以你不需要寻找其他方法。然而，有些技术可以最大限度地提高这些操作的效率。

首先，看一个例子。这是连接字符串的常用方法：
str += "one" + "two";
此代码执行时，发生四个步骤：
1.内存中创建了一个临时字符串。
2.临时字符串的值被赋予“onetwo”。
3.临时字符串与str 的值进行连接。
4. 结果赋予str。
这基本上就是浏览器完成这一任务的过程。

下面的代码通过两个离散表达式直接将内容附加在str 上避免了临时字符串（上面列表中第1 步和第2步）。在大多数浏览器上这样做可加快10%-40%：
str += "one";
str += "two";

实际上，你可以用一行代码就实现这样的性能提升，如下：
str = str + "one" + "two";
// equivalent to str = ((str + "one") + "two")

这就避免了使用临时字符串，因为赋值表达式开头以str 为基础，一次追加一个字符串，从左至右依次连接。如果改变连接顺序（例如，str = "one" + str + "two"），你会失去这种优化。这与浏览器合并字符串时分配内存的方法有关。除IE 以外，浏览器尝试扩展表达式左端字符串的内存，然后简单地将第二个字符串拷贝到它的尾部（如图5-1）。如果在一个循环中，基本字符串位于最左端，就可以避免多次复制一个越来越大的基本字符串。

这些技术并不适用于IE。它们几乎没有任何作用，在IE8 上甚至比IE7 和早期版本更慢。这与IE 执行连接操作的机制有关。在IE8 中，连接字符串只是记录下构成新字符串的各部分字符串的引用。在最后时刻（当你真正使用连接后的字符串时），各部分字符串才被逐个拷贝到一个新的“真正的”字符串中，然后用它取代先前的字符串引用，所以并非每次使用字符串时都发生合并操作。

IE7 和更早的浏览器在连接字符串时使用更糟糕的实现方法，每连接一对字符串都要把它们复制到一块新分配的内存中。你会在后面的“数组联结”一节中看到它潜在的巨大影响。针对IE8 之前的实现方式，本节的建议反而会使代码更慢，因为合并多个短字符串比连接一个大字符串更快（避免多次拷贝那些大字符串）。例如，largeStr = largeStr + s1 + s2 语句，在IE7 和更早的版本中，必须将这个大字符串拷贝两次，首先与s1 合并，然后再与s2 合并。相反，largeStr = s1 + s2 首先将两个小字符串合并起来，然后将结果返回给大字符串。创建中间字符串s1 + s2 与两次拷贝大字符串相比，性能冲击要轻得多。


Firefox and compile-time folding Firefox 和编译期合并
在赋值表达式中所有字符串连接都属于编译期常量，Firefox 自动地在编译过程中合并它们。这里有一个方法可看到这一过程：
function foldingDemo() {
var str = "compile" + "time" + "folding";
str += "this" + "works" + "too";
str = str + "but" + "not" + "this";
}
alert(foldingDemo.toString());
// In Firefox, you'll see this:
// function foldingDemo() {
// var str = "compiletimefolding";
// str += "thisworkstoo";
// str = str + "but" + "not" + "this";
// }

当字符串是这样合并在一起时，由于运行时没有中间字符串，所以连接它们的时间和内存可以减少到零。这种功能非常了不起，但它并不经常起作用，因为通常从运行期数据创建字符串而不是从编译期常量。


Array Joining 数组联结
Array.prototype.join 方法将数组的所有元素合并成一个字符串，并在每个元素之间插入一个分隔符字符串。如果传递一个空字符串作为分隔符，你可以简单地将数组的所有元素连接起来。

在大多数浏览器上，数组联结比连接字符串的其他方法更慢，但是事实上，为一种补偿方法，在IE7 和更早的浏览器上它是连接大量字符串唯一高效的途径。

下面的示例代码演示了可用数组联结解决的性能问题：
var str = "I'm a thirty-five character string.",
newStr = "",
appends = 5000;
while (appends--) {
newStr += str;
}

IE7 天真的连接算法要求浏览器在循环过程中反复地为越来越大的字符串拷贝和分配内存。结果是以平方关系递增的运行时间和内存消耗。

好消息是所有其他的现代浏览器（包括IE8）在这个测试中表现良好，不会呈现平方关系的复杂性递增，这是真正的杀手级改善。然而，此程序演示了看似简单的字符串连接所产生的影响。5'000 次连接用去226毫秒已经是一个显著的性能冲击了，应当尽可能地缩减这一时间，但锁定用户浏览器长达32 秒，只是为了连接20'000 个短字符串，则对任何应用程序来说都是不能接受的。

现在考虑下面的测试，它使用数组联结生成同样的字符串：
var str = "I'm a thirty-five character string.",
strs = [],
newStr,
appends = 5000;
while (appends--) {
strs[strs.length] = str;
}
newStr = strs.join("");

这一难以置信的改进结果是因为避免了重复的内存分配和拷贝越来越大的字符串。当联结一个数组时，浏览器分配足够大的内存用于存放整个字符串，也不会超过一次地拷贝最终字符串的同一部分。


String.prototype.concat
符串最灵活的方法，因为你可以用它追加一个字符串，或者一次追加几个字符串，或者一个完整的字符串数组。
// append one string
str = str.concat(s1);
// append three strings
str = str.concat(s1, s2, s3);
// append every string in an array by using the array
// as the list of arguments
str = String.prototype.concat.apply(str, array);

不幸的是，大多数情况下concat 比简单的+和+=慢一些，而且在IE，Opera 和Chrome 上大幅变慢。此外，虽然使用concat 合并数组中的所有字符串看起来和前面讨论的数组联结差不多，但通常它更慢一些（Opera 除外），而且它还潜伏着灾难性的性能问题，正如IE7 和更早版本中使用+和+=创建大字符串那样。


Regular Expression Optimization 正则表达式优化
两个正则表达式匹配相同的文本并不意味着他们具有同等的速度。

许多因素影响正则表达式的效率。首先，正则表达式适配的文本千差万别，部分匹配时比完全不匹配所用的时间要长。每种浏览器的正则表达式引擎也有不同的内部优化。



How Regular Expressions Work 正则表达式工作原理
下面是一个正则表达式处理的基本步骤：
第一步：编译
当你创建了一个正则表达式对象之后（使用一个正则表达式直接量或者RegExp 构造器），浏览器检查你的模板有没有错误，然后将它转换成一个本机代码例程，用于执行匹配工作。如果你将正则表达式赋给一个变量，你可以避免重复执行此步骤。

第二步：设置起始位置
当一个正则表达式投入使用时，首先要确定目标字符串中开始搜索的位置。它是字符串的起始位置，或者由正则表达式的lastIndex 属性指定，但是当它从第四步返回到这里的时候（因为尝试匹配失败），此位置将位于最后一次尝试起始位置推后一个字符的位置上。

浏览器厂商优化正则表达式引擎的办法是，在这一阶段中通过早期预测跳过一些不必要的工作。例如，如果一个正则表达式以^开头，IE 和Chrome 通常判断在字符串起始位置上是否能够匹配，然后可避免愚蠢地搜索后续位置。另一个例子是匹配第三个字母是x 的字符串，一个聪明的办法是先找到x，然后再将起
始位置回溯两个字符（例如，最近的Chrome 版本实现了这种优化）。

第三步：匹配每个正则表达式的字元
正则表达式一旦找好起始位置，它将一个一个地扫描目标文本和正则表达式模板。当一个特定字元匹配失败时，正则表达式将试图回溯到扫描之前的位置上，然后进入正则表达式其他可能的路径上。

第四步：匹配成功或失败
如果在字符串的当前位置上发现一个完全匹配，那么正则表达式宣布成功。如果正则表达式的所有可能路径都尝试过了，但是没有成功地匹配，那么正则表达式引擎回到第二步，从字符串的下一个字符重新尝试。只有字符串中的每个字符（以及最后一个字符后面的位置）都经历了这样的过程之后，还没有成功匹配，那么正则表达式就宣布彻底失败。

牢记这一过程将有助于您明智地判别那些影响正则表达式性能问题的类型。接下来我们深入剖析第三步中匹配过程的关键点：回溯。


Understanding Backtrack 理解回溯
在大多数现代正则表达式实现中（包括JavaScript 所需的），回溯是匹配过程的基本组成部分。它很大程度上也是正则表达式如此美好和强大的根源。然而，回溯计算代价昂贵，如果你不够小心的话容易失控。虽然回溯是整体性能的唯一因素，理解它的工作原理，以及如何减少使用频率，可能是编写高效正则表达式最重要的关键点。因此后面几节用较长篇幅讨论这个话题。

当一个正则表达式扫描目标字符串时，它从左到右逐个扫描正则表达式的组成部分，在每个位置上测试能不能找到一个匹配。对于每一个量词和分支，都必须决定如何继续进行。如果是一个量词（诸如*，+?，或者{2,}），正则表达式必须决定何时尝试匹配更多的字符；如果遇到分支（通过|操作符），它必须从这些选项中选择一个进行尝试。

每当正则表达式做出这样的决定，如果有必要的话，它会记住另一个选项，以备将来返回后使用。如果所选方案匹配成功，正则表达式将继续扫描正则表达式模板，如果其余部分匹配也成功了，那么匹配就结束了。但是如果所选择的方案未能发现相应匹配，或者后来的匹配也失败了，正则表达式将回溯到最后一个决策点，然后在剩余的选项中选择一个。它继续这样下去，直到找到一个匹配，或者量词和分支选项的所有可能的排列组合都尝试失败了，那么它将放弃这一过程，然后移动到此过程开始位置的下一个字符上，重复此过程。


Alternation and backtracking 分支和回溯
下面的例子演示了这一过程是如何处理分支的。
/h(ello|appy) hippo/.test("hello there, happy hippo");

此正则表达式匹配“hello hippo”或“happy hippo”。测试一开始，它要查找一个h，目标字符串的第一个字母恰好就是h，它立刻就被找到了。接下来，子表达式（ello|appy）提供了两个处理选项。正则表达式选择最左边的选项（分支选择总是从左到右进行），检查ello 是否匹配字符串的下一个字符。确实匹配，然后正则表达式又匹配了后面的空格。然而在这一点上它走进了死胡同，因为hippo 中的h 不能匹配字符串中
的下一个字母t。此时正则表达式还不能放弃，因为它还没有尝试过所有的选择，随后它回溯到最后一个检查点（在它匹配了首字母h 之后的那个位置上）并尝试匹配第二个分支选项。但是没有成功，而且也没有更多的选项了，所以正则表达式认为从字符串的第一个字符开始匹配是不能成功的，因此它从第二个字符开始，重新进行查找。它没有找到h，所以就继续向后找，直到第14 个字母才找到，它匹配happy 的那个h。然后它再次进入分支过程。这次ello 未能匹配，但是回溯之后第二次分支过程中，它匹配了整个字符串“happy hippo”。匹配成功了。
demo: hello.docx


Repetition and backtracking 重复与回溯
下一个例子显示了带重复量词的回溯。
var str = "<p>Para 1.</p>" +
"<img src='smiley.jpg'>" +
"<p>Para 2.</p>" +
"<div>Div.</div>";
/<p>.*<\/p>/i.test(str);

正则表达式一上来就匹配了字符串开始的三个字母<p>。然后是.*。点号匹配除换行符以外的任意字符，星号这个贪婪量词表示重复零次或多次——匹配尽量多的次数。因为目标字符串中没有换行符，它将吞噬
剩下的全部字符串！不过正则表达式模板中还有更多内容需要匹配，所以正则表达式尝试匹配<。它在字符串末尾匹配不成功，所以它每次回溯一个字符，继续尝试匹配<，直到它回到</div>标签的<位置。然后它尝试匹配\/（转义反斜杠），匹配成功，然后是p，匹配不成功。正则表达式继续回溯，重复此过程，直到第二段末尾时它终于匹配了</p>。匹配返回成功，它从第一段头部一直扫描到最后一个的末尾，这可能不是你想要的结果。

你可以将正则表达式中的贪婪量词*改为懒惰（又名非贪婪）量词*?，以匹配单个段落。懒惰量词的回溯工作以相反方式进行。当正则表达式/<p>.*?<\/p>/推进到.*?时，它首先尝试全部跳过然后继续匹配<\/p>。它这么做是因为*?匹配零次或多次，但尽可能少重复，尽可能少的话那么它就可以重复零次。但是，当随后的<在字符串的这一点上匹配失败时，正则表达式回溯并尝试下一个最小的字符数：一个。它继续像这样向前回溯到第一段的末尾，在那里量词后面的<\/p>得到完全匹配。

如果目标字符串只有一个段落，你可以看到此正则表达式的贪婪版本和懒惰版本是等价的，但是他们尝试匹配的过程不同。
demo: p.docx


Runaway Backtracking 回溯失控
当一个正则表达式占用浏览器上秒，上分钟或者更长时间时，问题原因很可能是回溯失控。为说明此问题，考虑下面的正则表达式，它的目标是匹配整个HTML 文件。此表达式被拆分成多行是为了适合页面显示。不像其他大多数正则表达式那样，JavaScript 没有选项可使点号匹配任意字符，包括换行符，所以此例中以[\s\S]匹配任意字符。
/<html>[\s\S]*?<head>[\s\S]*?<title>[\s\S]*?<\/title>[\s\S]*?<\/head>
[\s\S]*?<body>[\s\S]*?<\/body>[\s\S]*?<\/html>/

此正则表达式匹配正常HTML 字符串时工作良好，但是如果目标字符串缺少一个或多个标签时，它就会变得十分糟糕。例如</html>标签缺失，那么最后一个[\s\S]*?将扩展到字符串的末尾，因为在那里没有发现</html>标签，然后并没有放弃，正则表达式将察看此前的[\s\S]*?队列记录的回溯位置，使它们进一步扩大。正则表达式尝试扩展倒数第二个[\s\S]*?——用它匹配</body>标签，就是此前匹配过正则表达式模板
<\/body>的那个标签——然后继续查找第二个</body>标签直到字符串的末尾。当所有这些步骤都失败了，倒数第三个[\s\S]*?将被扩展直至字符串的末尾，依此类推。

The solution: Be specific 解决方法：具体化
此类问题的解决办法在于尽可能具体地指出分隔符之间的字符匹配形式。例如模板".*?"用于匹配双引号包围的一个字符串。用更具体的[^"\rn]*取代过于宽泛的.*?，就去除了回溯时可能发生的几种情况，如尝试用点号匹配引号，或者扩展搜索超出预期范围。

在HTML 的例子中解决办法不是那么简单。你不能使用否定字符类型如[^<]替代[\s\S]因为在搜索过程中可能会遇到其他类型的标签。但是，你可以通过重复一个非捕获组来达到同样效果，它包含一个回顾（阻塞下一个所需的标签）和[\s\S]（任意字符）元序列。这确保中间位置上你查找的每个标签都会失败，然后，更重要的是，[\s\S]模板在你在回顾过程中阻塞的标签被发现之前不能被扩展。应用此方法后正则表达式最终修改如下：
/<html>(?:(?!<head>)[\s\S])*<head>(?:(?!<title>)[\s\S])*<title>
(?:(?!<\/title>)[\s\S])*<\/title>(?:(?!<\/head>)[\s\S])*<\/head>
(?:(?!<body>)[\s\S])*<body>(?:(?!<\/body>)[\s\S])*<\/body>
(?:(?!<\/html>)[\s\S])*<\/html>/
虽然这样做消除了潜在的回溯失控，并允许正则表达式匹配不完整HTML 字符串失败时，其使用时间与文本长度呈线性关系，但是它的效率并没有提高。像这样为每个匹配字符多次前瞻缺乏效率，而且成功匹配过程也相当慢。匹配较短字符串时此方法相当不错，但匹配一个HTML 文件可能需要前瞻并测试上千
次。另外一种解决方案更好，它使用了一点小技巧，如下：


Emulating atomic groups using lookahead and backreferences 使用前瞻和后向引用列举原子组
一些正则表达式引擎，如.NET，Java，Oniguruma，PCRE，Perl，支持一种称作原子组的属性。原子组，写作(?>…)（译者注：有的书上称“贪婪子表达式”），省略号表示任意正则表达式模板——非捕获组和一个特殊的扭曲。存在于原子组中的正则表达式组中的任何回溯点都将被丢弃。这就为HTML 正则表达式的回溯问题提供了一个更好的解决办法：如果你将[\s\S]*?序列和它后面的HTML 标记一起放在一个原子组中，每当所需的HTML 标签被发现一次，这次匹配基本上就被锁定了。如果正则表达式的后续部分匹配失败，原子组中的量词没有记录回溯点，因此[\s\S]*?序列就不能扩展到已匹配的范围之外。

这是了不起的技术。但是，JavaScript 不支持原子组，也不提供其他方法消除不必要的回溯。不过，你可以利用前瞻过程中一项鲜为人知的行为来模拟原子组：前瞻也是原子组。不同的是，前瞻在整个匹配过程中，不消耗字符；它只是检查自己包含的模板是否能在当前位置匹配。然而，你可以避开这点，在捕获组中包装一个前瞻模板，在前瞻之外向它添加一个后向引用。它看起来是下面这个样子：
(?=(pattern to make atomic))\1

记住，你需要使用适当的后向引用次数如果你的正则表达式包含多个捕获组。

HTML 正则表达式使用此技术后修改如下：
/<html>(?=([\s\S]*?<head>))\1(?=([\s\S]*?<title>))\2(?=([\s\S]*?
<\/title>))\3(?=([\s\S]*?<\/head>))\4(?=([\s\S]*?<body>))\5
(?=([\s\S]*?<\/body>))\6[\s\S]*?<\/html>/

现在如果没有尾随的</html>那么最后一个[\s\S]*?将扩展至字符串结束，正则表达式将立刻失败因为没有回溯点可以返回。正则表达式每次找到一个中间标签就退出一个前瞻，它在前瞻过程中丢弃所有回溯位置。下一个后向引用简单地重新匹配前瞻过程中发现的字符，将他们作为实际匹配的一部分。


Nested quantifiers and runaway backtracking 嵌套量词和回溯失控
所谓嵌套量词总是需要额外的关注和小心，以确保没有掩盖回溯失控问题。嵌套量词指的是它出现在一个自身被重复量词修饰的组中（例如(x+)*）。

嵌套量词本身并不会造成性能危害。然而，如果你不小心，它很容易在尝试匹配字符串过程中，在内部量词和外部量词之间，产生一大堆分解文本的方法。

例如，假设你想匹配的HTML 标签，使用了下面的正则表达式：
/<(?:[^>"']|"[^"]*"|'[^']*')*>/

这也许过于简单，因为它不能正确处理所有情况的有效和无效标记，但它处理有效HTML 片段时应该没什么问题。与更加幼稚的/<[^>]*>/相比，它的优势在于涵盖了出现在属性值中的>符号。在非捕获组中它不使用第二个和第三个分支，它们匹配单引号和双引号包围的属性值，除特定的引号外允许所有字符出现。

到目前为止还没有回溯失控的危险，尽管遇到了嵌套量词*。分组的每次重复过程中，第二和第三分支选项严格匹配一个带引号的字符串，所以潜在的回溯点数目随目标字符串长度而线性增长。

但是，察看非捕获组的第一个分支：[^>"']，每次只匹配一个字符，似乎有些效率低下。你可能认为在字符类后面加一个+量词会更好些，这样一来每次组重复过程就可以匹配多于一个的字符了。正则表达式可以在目标字符串的那个位置上发现一个匹配。你是对的，通过每次匹配多个字符，你让正则表达式在成功匹配的过程中跳过许多不必要的步骤。

没有什么比这种改变所带来的负面效应更显而易见了。如果正则表达式匹配一个<字符，但后面没有>，却可以令匹配成功完成，回溯失控就会进入快车道，因为内部量词和外部量词的排列组合产生了数量巨大的分支路径（跟在非捕获组之后）用以匹配<之后的文本。正则表达式在最终放弃匹配之前必须尝试所有的排列组合。要当心啊！


From bad to worse. 从坏到更坏
关于嵌套量词导致回溯失控一个更极端的例子是，在一大串A 上应用正则表达式/(A+A+)+B/。虽然这个正则表达式写成/AA+B/更好，但为了讨论方便，设想一下两个A 能够匹配同一个字符串的多少种模板。

当应用在一个由10 个A 组成的字符串上（“AAAAAAAAAA”），正则表达式首先使用第一个A+匹配了所有10 个字符。然后正则表达式回溯一个字符，让第二个A+匹配最后一个字符。然后这个分组试图重复，但是没有更多的A 而且分组中的+量词已经符合匹配所需的最少一次，因此正则表达式开始查找B。它没有找到，但是还不能放弃，因为还有许多路径没有被测试过。如果第一个A+匹配8 个字符，第二个
A+匹配2 个字符会怎么样呢？或者第一个匹配3 个，第二个匹配2 个，分组重复两次，又会怎么样呢？如果在分组的第一遍重复中，第一个A+匹配2 个字符，第二个A+匹配3 个字符，然后第二遍重复中，第一个匹配1 个，第二个匹配4 个，又怎么样呢？虽然你我都不会笨到认为多次回溯后可以找到那个并不存在的B，但是正则表达式只会忠实地一次又一次地检查所有这些无用的选项。此正则表达式最坏情况的复杂性是一个惊人的O(2n)，也就是2 的n 次方。n 表示字符串的长度。在10 个A 构成的字符串中，正则表达式需要1024 次回溯才能确定匹配失败，如果是20 个A，该数字剧增到一百万以上。25 个A足以挂起Chrome，IE，Firefox，和Opera 至少10 分钟（如果还没死机的话）用以处理超过三千四百万次回溯以排除正则表达式的各种排列组合。唯一的例外是最新的Safari，它能够检测正则表达式陷入了循环，并快速终止匹配（Safari 还限定了回溯的次数，超出则终止匹配尝试）。

预防此类问题的关键是确保正则表达式的两个部分不能对字符串的同一部分进行匹配。这个正则表达式可重写为/AA+B/，但复杂的正则表达式可能难以避免此类问题。增加一个模拟原子组往往作为最后一招使用，虽然还有其他解决办法，如果可能的话，尽可能保持你的正则表达式简单易懂。如果这么做此正则表达式将改成/((?=(A+A+))\2)+B/，就彻底消除了回溯问题。


A Note on Benchmarking 测试基准说明
因为正则表达式性能因应用文本不同而产生很大差异，没有简单明了的方法可以测试正则表达式之间的性能差别。为得到最好的结果，你需要在各种字符串上测试你的正则表达式，包括不同长度，能够匹配的，不能匹配的，和近似匹配的。

这也是本章长篇大论回溯的原因之一。如果没有确切理解回溯，就无法预测和确定回溯相关问题。为帮助你早日把握回溯失控，总是用包含特殊匹配的长字符串测试你的正则表达式。针对你的正则表达式构思一些近似但不能完全匹配的字符串，将他们应用在你的测试中。


More Ways to Improve Regular Expression Efficiency 提高正则表达式效率的更多方法
下面是一写提高正则表达式效率的技术。几个技术点已经在回溯部分讨论过了。

关注如何让匹配更快失败
正则表达式处理慢往往是因为匹配失败过程慢，而不是匹配成功过程慢。如果你使用正则表达式匹配一个很大字符串的一小部分，情况更为严重，正则表达式匹配失败的位置比匹配成功的位置要多得多。如果一个修改使正则表达式匹配更快但失败更慢（例如，通过增加所需的回溯次数去尝试所有分支的排列组
合），这通常是一个失败的修改。

正则表达式以简单的，必需的字元开始
最理想的情况是，一个正则表达式的起始字元应当尽可能快速地测试并排除明显不匹配的位置。用于此目的好的起始字元通常是一个锚（^或$），特定字符（例如x 或\u363A），字符类（例如，[a-z]或速记符例如\d），和单词边界（\b）。如果可能的话，避免以分组或选择字元开头，避免顶级分支例如/one|two/，因为它强迫正则表达式识别多种起始字元。Firefox 对起始字元中使用的任何量词都很敏感，能够优化的更好，例如，以\s\s*替代\s+或\s{1,}。其他浏览器大多优化掉这些差异。

编写量词模板，使它们后面的字元互相排斥
当字符与字元毗邻或子表达式能够重叠匹配时，一个正则表达式尝试分解文本的路径数量将增加。为避免此现象，尽量具体化你的模板。当你想表达“[^"\r\n]*”时不要使用“.*?”（依赖回溯）。

减少分支的数量，缩小它们的范围
分支使用 | ，竖线，可能要求在字符串的每一个位置上测试所有的分支选项。你通常可通过使用字符类和选项组件减少对分支的需求，或将分支在正则表达式上的位置推后（允许到达分支之前的一些匹配尝试失败）。
demo: reg.docx

字符类比分支更快，因为他们使用位向量实现（或其他快速实现）而不是回溯。当分支必不可少时，将常用分支放在最前面，如果这样做不影响正则表达式匹配的话。分支选项从左向右依次尝试，一个选项被匹配上的机会越多，它被检测的速度就越快。

注意Chrome 和Firefox 自动执行这些优化中的某些项目，因此较少受到手工调整的影响。

使用非捕获组
捕获组花费时间和内存用于记录后向引用，并保持它们是最新的。如果你不需要一个后向引用，可通过使用非捕获组避免这种开销——例如，(?:…)替代（…）。有些人当他们需要一个完全匹配的后向引用时，喜欢将他们的正则表达式包装在一个捕获组中。这是不必要的，因为你能够通过其他方法引用完全匹配，例如，使用regex.exec()返回数组的第一个元素，或替换字符串中的$&。

用非捕获组取代捕获组在Firefox 中影响很小，但在其他浏览器上处理长字符串时影响很大。

捕获感兴趣的文字，减少后处理
最后一个告诫，如果你需要引用匹配的一部分，应当通过一切手段，捕获那些片断，再使用后向引用处理。例如，如果你写代码处理一个正则表达式所匹配的引号中的字符串内容，使用/"([^"]*)"/然后使用一次后向引用，而不是使用/"[^"]*"/然后从结果中手工剥离引号。当在循环中使用时，减少这方面的工作可以节省大量时间。

暴露所需的字元
为帮助正则表达式引擎在如何优化查询例程时做出明智的决策，应尽量简单地判断出那些必需的字元。当字元应用在子表达式或者分支中，正则表达式引擎很难判断他们是不是必需的，有些引擎并不作此方面努力。例如，正则表达式/^(ab|cd)/暴露它的字符串起始锚。IE 和Chrome 会注意到这一点，并阻止正则表达式尝试查找字符串头端之后的匹配，从而使查找瞬间完成而不管字符串长度。但是，由于等价正则表达式/(^ab|^cd)/不暴露它的^锚，IE 无法应用同样的优化，最终无意义地搜索字符串并在每一个位置上匹配。

使用适当的量词
正如前一节《重复和回溯》所讨论过的那样，贪婪量词和懒惰量词即使匹配同样的字符串，其查找匹配过程也是不同的。在确保正确等价的前提下，使用更合适的量词类型（基于预期的回溯次数）可以显著提高性能，尤其在处理长字符串时。

懒惰量词在Opera 9.x 和更早版本上格外缓慢，但Opera 10 消除了这一弱点。

将正则表达式赋给变量，以重用它们。

将正则表达式赋给变量以避免对它们重新编译。有人做的太过火，使用正则表达式缓存池，以避免对给定的模板和标记组合进行多次编译。不要过分忧虑，正则表达式编译很快，这样的缓存池所增加的负担可能超过他们所避免的。重要的是避免在循环体中重复编译正则表达式。换句话说，不要这样做：
while (/regex1/.test(str1)) {
/regex2/.exec(str2);
...
}

替代以如下做法：
var regex1 = /regex1/,
regex2 = /regex2/;
while (regex1.test(str1)) {
regex2.exec(str2);
...
}

将复杂的正则表达式拆分为简单的片断
尽量避免一个正则表达式做太多的工作。复杂的搜索问题需要条件逻辑，拆分为两个或多个正则表达式更容易解决，通常也更高效，每个正则表达式只在最后的匹配结果中执行查找。在一个模板中完成所有工作的正则表达式怪兽很难维护，而且容易引起回溯相关的问题。


When Not to Use Regular Expressions 什么时候不应该使用正则表达式
小心使用它，正则表达式是非常快的。然而，当你只是搜索文字字符串时它们经常矫枉过正。尤其当你事先知道了字符串的哪一部分将要被测试时。例如，如果你想检查一个字符串是不是以分号结束，你可以使用：
endsWithSemicolon = /;$/.test(str);

你可能觉得很奇怪，虽说当前没有哪个浏览器聪明到这个程度，能够意识到这个正则表达式只能匹配字符串的末尾。最终它们所做的将是一个一个地测试了整个字符串。每当发现了一个分号，正则表达式就前进到下一个字元（$），检查它是否匹配字符串的末尾。如果不是这样的话，正则表达式就继续搜索匹配，直到穿越了整个字符串。字符串的长度越长（包含的分号越多），它占用的时间也越长。

这种情况下，更好的办法是跳过正则表达式所需的所有中间步骤，简单地检查最后一个字符是不是分号：
endsWithSemicolon = str.charAt(str.length - 1) == ";";

目标字符串很小时，这种方法只比正则表达式快一点，但更重要的是，字符串的长度不再影响执行测试所需要的时间。

这个例子使用charAt 函数在特定位置上读取字符。字符串函数slice，substr，和substring 可用于在特定位置上提取并检查字符串的值。此外，indexOff 和lastIndexOf 函数非常适合查找特定字符串的位置，或者判断它们是否存在。所有这些字符串操作函数速度都很快，当您搜索那些不依赖正则表达式复杂特性的文本字符串时，它们有助于您避免正则表达式带来的性能开销。


String Trimming 字符串修剪
修剪字符串不是一个常见的性能瓶颈，但作为学习正则表达式优化的例子有多种实现方法。


Trimming with Regular Expressions 用正则表达式修剪
正则表达式允许你用很少的代码实现一个修剪函数，这对JavaScript 关心文件大小的库来说十分重要。可能最好的全面解决方案是使用两个子表达式：一个用于去除头部空格，另一个用于去除尾部空格。这样处理简单而迅速，特别是处理长字符串时。

if (!String.prototype.trim) {
String.prototype.trim = function() {
return this.replace(/^\s+/, "").replace(/\s+$/, "");
}
}
// test the new method...
// tab (\t) and line feed (\n) characters are
// included in the leading whitespace.
var str = " \t\n test string ".trim();
alert(str == "test string"); // alerts "true"

if 语句避免覆盖trim 函数如果它已经存在，因为原生函数进行了优化，通常远远快于你用JavaScript 自己写的函数。后面的例子假设这个条件已经判断过了，所以不是每次都写上。

你可以给Firefox 一个大约35%的性能提升（或多或少依赖于目标字符串的长度和内容）通过将/\s+$/（第二个正则表达式）替换成/\s\s*$/。虽然这两个正则表达式的功能完全相同，Firefox 却为那些以非量词字元开头的正则表达式提供额外的优化。在其他浏览器上，差异不显著，或者优化完全不同。然而，改变正则表达式，在字符串开头匹配/^\s\s*/不会产生明显差异，因为^锚需要照顾那些快速作废的非匹配位置（避免一个轻微的性能差异，因为在一个长字符串中可能产生上千次匹配尝试）。

以下是几个基于正则表达式的修剪实例，这是你可能会遇到的几个常见的替代品。你可以在本节末尾表5-2 中看到这里讨论的trim 实例在不同浏览器上的性能。事实上，除这里列出的之外还有许多方法，你可以写一个正则表达式来修剪字符串，但它们在处理长字符串时，总比用两个简单的表达式要慢（至少在跨浏览器时缺乏一致性）。
// trim 2
String.prototype.trim = function() {
return this.replace(/^\s+|\s+$/g, "");
}

这可能是最通常的解决方案。它通过分支功能合并了两个简单的正则表达式，并使用/g（全局）标记替换所有匹配，而不只是第一个（当目标字符串首尾都有空格时它将匹配两次）。这并不是一个可怕的方法，但是对长字符串操作时，它比使用两个简单的子表达式要慢，因为两个分支选项都要测试每个字符位置。
// trim 3
String.prototype.trim = function() {
return this.replace(/^\s*([\s\S]*?)\s*$/, "$1");
}

这个正则表达式的工作原理是匹配整个字符串，捕获从第一个到最后一个非空格字符之间的序列，记入后向引用1。然后使用后向引用1 替代整个字符串，就留下了这个字符串的修剪版本。

这个方法概念简单，但捕获组里的懒惰量词使正则表达式进行了许多额外操作（例如，回溯），因此在操作长目标字符串时很慢。进入正则表达式捕获组时，[\s\S]类的懒惰量词*?要求它尽可能地减少重复次数。因此，这个正则表达式每匹配一个字符，都要停下来尝试匹配余下的\s*$模板。如果字符串当前位置之后存在非空格字符导致匹配失败，正则表达式将匹配一个或多个字符，更新后向引用，然后再次尝试模板的剩余部分。

在Opera 9.x 和更早版本中懒惰重复特别慢。因此，这个方法在Opera 9.64 上比其它大型浏览器慢了10到100 倍。Opera 10 修正了这个长期存在的弱点，将此方法的性能提高到与其它浏览器相当的水平。
// trim 4
String.prototype.trim = function() {
return this.replace(/^\s*([\s\S]*\S)?\s*$/, "$1");
}

这个表达式与上一个很像，但出于性能原因以贪婪量词取代了懒惰量词。为确保捕获组只匹配到最后一个非空格字符，必需尾随一个\S。然而，由于正则表达式必需能够匹配全部由空格组成的字符串，整个捕获组通过尾随一个?量词而成为可选组。

在此，[\s\S]*中的贪婪量词“*”表示重复方括号中的任意字符模板直至字符串结束。然后正则表达式每次回溯一个字符，直到它能够匹配后面的\S，或者直到回溯到第一个字符而匹配整个组（然后它跳过这个组）。

如果尾部空格不比其它字符串更多，它通常比前面那些使用懒惰量词的方案更快。事实上，它在IE，Safari，Chrome 和Opear 10 上如此之快，甚至超过使用两个子表达式的方案。因为这些浏览器包含特殊优化，专门服务于为字符类匹配任意字符的贪婪重复操作。正则表达式引擎直接跳到字符串末尾而不检查中间的字符（尽管回溯点必需被记下来），然后适当回溯。不幸的是，这种方法在Firefox 和Opera 9 上非常慢，所以到目前为止，使用两个子表达式仍然是更好的跨浏览器方案。
// trim 5
String.prototype.trim = function() {
return this.replace(/^\s*(\S*(\s+\S+)*)\s*$/, "$1");
}

这是一个相当普遍的方法，但没有很好的理由使用它，因为它在所有浏览器上都是这里列出所有方法中最慢的一个。它类似最后两个正则表达式，它匹配整个字符串然后用你打算保留的部分替换这个字符串，因为内部组每次只匹配一个单词，正则表达式必需执行大量的离散步骤。修剪短字符串时性能冲击并不明显，但处理包含多个词的长字符串时，这个正则表达式可以成为一个性能问题。

将内部组修改为一个非捕获组——例如，将(\s+\S+)修改为（?:\s+\S+）——有一点帮助，在Opera，IE和Chrome 上缩减了大约20%-45%的处理时间，在Safari 和Firefox 上也有轻微改善。尽管如此，一个非捕获组不能完全代换这个实现。请注意，外部组不能转换为非捕获组，因为它在被替换的字符串中被引用了。


Trimming Without Regular Expressions 不使用正则表达式修剪
虽然正则表达式很快，还是值得考虑没有它们帮助时修剪字符串的性能。有一种方法这样做：
// trim 6
String.prototype.trim = function() {
    var start = 0,
    end = this.length - 1,
    ws = " \n\r\t\f\x0b\xa0\u1680\u180e\u2000\u2001\u2002\u2003
    \u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f
    \u205f\u3000\ufeff";
    while (ws.indexOf(this.charAt(start)) > -1) {
        start++;
    }
    while (end > start && ws.indexOf(this.charAt(end)) > -1) {
        end--;
    }
    return this.slice(start, end + 1);
}
此代码中的ws 变量包括ECMAScript 5 中定义的所有空白字符。出于效率原因，在得到修剪区的起始和终止位置之前避免拷贝字符串的任何部分。

当字符串末尾只有少量空格时，这种情况使正则表达式陷入疯狂工作。原因是，尽管正则表达式很好地去除了字符串头部的空格，它们却不能同样快速地修剪长字符串的尾部。正如《什么时候不应该使用正则表达式》一节所提到的那样，一个正则表达式不能跳到字符串的末尾而不考虑沿途字符。然而，本实现正是如此，在第二个while 循环中从字符串末尾向前查找一个非空格字符。

虽然本实现不受字符串总长度影响，但它有自己的弱点：（它害怕）长的头尾空格。因为循环检查字符是不是空格在效率上不如正则表达式所使用的优化过的搜索代码。


A Hybrid Solution 混合解决方案
本节中最后一个办法是将两者结合起来，用正则表达式修剪头部空格，用非正则表达式方法修剪尾部字符。
// trim 7
String.prototype.trim = function() {
var str = this.replace(/^\s+/, ""),
end = str.length - 1,
ws = /\s/;
while (ws.test(str.charAt(end))) {
end--;
}
return str.slice(0, end + 1);
}

当只修剪一个空格时，此混合方法巨快无比，并去除了性能上的风险，诸如以长空格开头的字符串，完全由空格组成的字符串（尽管它在处理尾部长空格的字符串时仍然具有弱点）。请注意，此方案在循环中使用正则表达式检测字符串尾部的字符是否空格，尽管使用正则表达式增加了一点性能负担，但它允许你根据浏览器定义空格字符列表，以保持简短和兼容性。

所有修剪方法总的趋势是：在基于正则表达式的方案中，字符串总长比修剪掉的字符数量更影响性能；而非正则表达式方案从字符串末尾反向查找，不受字符串总长的影响，但明显受到修剪空格数量的影响。简单地使用两个子正则表达式在所有浏览器上处理不同内容和长度的字符串时，均表现出稳定的性能。因此它可以说是最全面的解决方案。混合解决方案在处理长字符串时特别快，其代价是代码稍长，在某些浏览器上处理尾部长空格时存在弱点。


Summary 总结
密集的字符串操作和粗浅地编写正则表达式可能是主要性能障碍，但本章中的建议可帮助您避免常见缺陷。

当连接数量巨大或尺寸巨大的字符串时，数组联合是IE7 和它的早期版本上唯一具有合理性能的方法。

如果你不关心IE7 和它的早期版本，数组联合是连接字符串最慢的方法之一。使用简单的+和+=取而代之，可避免（产生）不必要的中间字符串。

回溯既是正则表达式匹配功能基本的组成部分，又是正则表达式影响效率的常见原因。

回溯失控发生在正则表达式本应很快发现匹配的地方，因为某些特殊的匹配字符串动作，导致运行缓慢甚至浏览器崩溃。避免此问题的技术包括：使相邻字元互斥，避免嵌套量词对一个字符串的相同部分多次匹配，通过重复利用前瞻操作的原子特性去除不必要的回溯。

提高正则表达式效率的各种技术手段，帮助正则表达式更快地找到匹配，以及在非匹配位置上花费更少时间（见《更多提高正则表达式效率的方法》）。

正则表达式并不总是完成工作的最佳工具，尤其当你只是搜索一个文本字符串时。

虽然有很多方法来修整一个字符串，使用两个简单的正则表达式（一个用于去除头部空格，另一个用于去除尾部空格）提供了一个简洁、跨浏览器的方法，适用于不同内容和长度的字符串。从字符串末尾开始循环查找第一个非空格字符，或者在一个混合应用中将此技术与正则表达式结合起来，提供了一个很好的替代方案，它很少受到字符串整体长度的影响。