第二章 Data Access 数据访问
在JavaScript 中有四种基本的数据访问位置：

Literal values 直接量
直接量仅仅代表自己，而不存储于特定位置。 JavaScript 的直接量包括：字符串，数字，布尔值，对象，数组，函数，正则表达式，具有特殊意义的空值，以及未定义。

Variables 变量
开发人员使用var 关键字创建用于存储数据值。

Array items 数组项
具有数字索引，存储一个JavaScript 数组对象。

Object members 对象成员
具有字符串索引，存储一个JavaScript 对象。

大多数情况下，对一个直接量和一个局部变量数据访问的性能差异是微不足道的。访问数组项和对象成员的代价要高一些，具体高多少，很大程度上依赖于浏览器。

一般的建议是，如果关心运行速度，那么尽量使用直接量和局部变量，限制数组项和对象成员的使用。


Managing Scope 管理作用域
Scope Chains and Identifier Resolution 作用域链和标识符解析

每一个JavaScript 函数都被表示为对象。进一步说，它是一个函数实例。函数对象正如其他对象那样，拥有你可以编程访问的属性，和一系列不能被程序访问，仅供JavaScript 引擎使用的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262 标准第三版定义。

内部[[Scope]]属性包含一个函数被创建的作用域中对象的集合。此集合被称为函数的作用域链，它决定哪些数据可由函数访问。此函数作用域链中的每个对象被称为一个可变对象，每个可变对象都以“键值对”的形式存在。当一个函数创建后，它的作用域链被填充以对象，这些对象代表创建此函数的环境中可访问的数据。例如下面这个全局函数：
function add(num1, num2){
var sum = num1 + num2;
return sum;
}

add 函数的作用域链将会在运行时用到。假设运行下面的代码：
var total = add(5, 10);
运行此add 函数时建立一个内部对象，称作“运行期上下文”。一个运行期上下文定义了一个函数运行时的环境。对函数的每次运行而言，每个运行期上下文都是独一的，所以多次调用同一个函数就会导致多次创建运行期上下文。当函数执行完毕，运行期上下文就被销毁。

一个运行期上下文有它自己的作用域链，用于标识符解析。当运行期上下文被创建时，它的作用域链被初始化，连同运行函数的[[Scope]]属性中所包含的对象。这些值按照它们出现在函数中的顺序，被复制到运行期上下文的作用域链中。这项工作一旦完成，一个被称作“激活对象”的新对象就为运行期上下文创建好了。此激活对象作为函数执行期的一个可变对象，包含访问所有局部变量，命名参数，参数集合，和this的接口。然后，此对象被推入作用域链的前端。当作用域链被销毁时，激活对象也一同销毁。
demo: 作用域链和标识符解析.docx

在函数运行过程中，每遇到一个变量，标识符识别过程要决定从哪里获得或者存储数据。此过程搜索运行期上下文的作用域链，查找同名的标识符。搜索工作从运行函数的激活目标之作用域链的前端开始。如果找到了，那么就使用这个具有指定标识符的变量；如果没找到，搜索工作将进入作用域链的下一个对象。此过程持续运行，直到标识符被找到，或者没有更多对象可用于搜索，这种情况下标识符将被认为是未定义的。函数运行时每个标识符都要经过这样的搜索过程，例如前面的例子中，函数访问sum，num1，num2时都会产生这样的搜索过程。正是这种搜索过程影响了性能。


Identifier Resolution Performance 标识符识别性能
在运行期上下文的作用域链中，一个标识符所处的位置越深，它的读写速度就越慢。所以，函数中局部变量的访问速度总是最快的，而全局变量通常是最慢的（优化的JavaScript 引擎在某些情况下可以改变这种状况）。请记住，全局变量总是处于运行期上下文作用域链的最后一个位置，所以总是最远才能触及的。

最好尽可能使用局部变量。一个好的经验法则是：用局部变量存储本地范围之外的变量值，如果它们在函数中的使用多于一次。
demo: identifier.htm

此函数包含三个对document 的引用，document 是一个全局对象。搜索此变量，必须遍历整个作用域链，直到最后在全局变量对象中找到它。你可以通过这种方法减轻重复的全局变量访问对性能的影响：首先将全局变量的引用存储在一个局部变量中，然后使用这个局部变量代替全局变量。
demo: identifier-modify.htm


Scope Chain Augmentation 改变作用域链
一般来说，一个运行期上下文的作用域链不会被改变。但是，有两种表达式可以在运行时临时改变运行期上下文作用域链。第一个是with 表达式。

with 表达式为所有对象属性创建一个默认操作变量。在其他语言中，类似的功能通常用来避免书写一些重复的代码。
demo: with.htm
此重写的initUI()版本使用了一个with 表达式，避免多次书写“document”。这看起来似乎更有效率，而实际上却产生了一个性能问题。

当代码流执行到一个with 表达式时，运行期上下文的作用域链被临时改变了。一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，所以访问代价更高。
demo: with.docx
通过将document 对象传递给with 表达式，一个新的可变对象容纳了document 对象的所有属性，被插入到作用域链的前端。这使得访问document 的属性非常快，但是访问局部变量的速度却变慢了，例如bd 变量。正因为这个原因，最好不要使用with 表达式。正如前面提到的，只要简单地将document 存储在一个
局部变量中，就可以获得性能上的提升。

在JavaScript 中不只是with 表达式人为地改变运行期上下文的作用域链，try-catch 表达式的catch 子句具有相同效果。当try 块发生错误时，程序流程自动转入catch 块，并将异常对象推入作用域链前端的一个可变对象中。在catch 块中，函数的所有局部变量现在被放在第二个作用域链对象中。
demo: try-catch.htm
请注意，只要catch 子句执行完毕，作用域链就会返回到原来的状态。

如果使用得当，try-catch 表达式是非常有用的语句，所以不建议完全避免。如果你计划使用一个try-catch语句，请确保你了解可能发生的错误。一个try-catch 语句不应该作为JavaScript 错误的解决办法。如果你知道一个错误会经常发生，那说明应当修正代码本身的问题。

你可以通过精缩代码的办法最小化catch 子句对性能的影响。一个很好的模式是将错误交给一个专用函数来处理
try {
methodThatMightCauseAnError();
} catch (ex){
handleError(ex); //delegate to handler method
}
handleError()函数是catch 子句中运行的唯一代码。此函数以适当方法自由地处理错误，并接收由错误产生的异常对象。由于只有一条语句，没有局部变量访问，作用域链临时改变就不会影响代码的性能。


Dynamic Scopes 动态作用域
无论是with 表达式还是try-catch 表达式的catch 子句，以及包含()函数，都被认为是动态作用域。一个动态作用域只因代码运行而存在，因此无法通过静态分析（察看代码结构）来确定（是否存在动态作用域）
function execute(code) {
    (code);
    function subroutine(){
        return window;
    }
    var w = subroutine();
    //what value is w?
};

execute()函数看上去像一个动态作用域，因为它使用了()。w 变量的值与code 有关。大多数情况下，w将等价于全局的window 对象，但是请考虑如下情况：
execute("var window = {};")

这种情况下，()在execute()函数中创建了一个局部window 变量。所以w 将等价于这个局部window 变量而不是全局的那个。所以说，不运行这段代码是没有办法了解具体情况的，标识符window 的确切含义不能预先确定。

优化的JavaScript 引擎，例如Safari 的Nitro 引擎，企图通过分析代码来确定哪些变量应该在任意时刻被访问，来加快标识符识别过程。这些引擎企图避开传统作用域链查找，取代以标识符索引的方式进行快速查找。当涉及一个动态作用域后，此优化方法就不起作用了。引擎需要切回慢速的基于哈希表的标识符识别方法，更像传统的作用域链搜索。

正因为这个原因，只在绝对必要时才推荐使用动态作用域。


Closures, Scope, and Memory 闭包，作用域，和内存
闭包是JavaScript 最强大的一个方面，它允许函数访问局部范围之外的数据。
demo: closure.htm

assignEvents()函数为一个DOM 元素指定了一个事件处理句柄。此事件处理句柄是一个闭包，当assignEvents()执行时创建，可以访问其范围内部的id 变量。用这种方法封闭对id 变量的访问，必须创建一个特定的作用域链。

当assignEvents()被执行时，一个激活对象被创建，并包含了一些应有的内容，其中包括id 变量。它将成为运行期上下文作用域链上的第一个对象，全局对象是第二个。当闭包创建时，[[Scope]]属性与这些对象一起被初始化。

由于闭包的[[Scope]]属性包含与运行期上下文作用域链相同的对象引用，会产生副作用。通常，一个函数的激活对象与运行期上下文一同销毁。当涉及闭包时，激活对象就无法销毁了，因为引用仍然存在于闭包的[[Scope]]属性中。这意味着脚本中的闭包与非闭包函数相比，需要更多内存开销。在大型网页应用中，
这可能是个问题，尤其在Internet Explorer 中更被关注。IE 使用非本地JavaScript 对象实现DOM 对象，闭包可能导致内存泄露（更多信息参见第3 章）。

当闭包被执行时，一个运行期上下文将被创建，它的作用域链与[[Scope]]中引用的两个相同的作用域链同时被初始化，然后一个新的激活对象为闭包自身被创建。

注意闭包中使用的两个标识符，id 和saveDocument，存在于作用域链第一个对象之后的位置上。这是闭包最主要的性能关注点：你经常访问一些范围之外的标识符，每次访问都导致一些性能损失。
demo: 闭包.docx

在脚本中最好是小心地使用闭包，内存和运行速度都值得被关注。但是，你可以通过本章早先讨论过的关于域外变量的处理建议，减轻对运行速度的影响：将常用的域外变量存入局部变量中，然后直接访问局部变量。


Object Members 对象成员
对象成员包括属性和方法，在JavaScript 中，二者差别甚微。对象的一个命名成员可以包含任何数据类型。既然函数也是一种对象，那么对象成员除传统数据类型外，也可以包含一个函数。当一个命名成员引用了一个函数时，它被称作一个“方法”，而一个非函数类型的数据则被称作“属性”。

正如本章前面所讨论过的，对象成员比直接量或局部变量访问速度慢，在某些浏览器上比访问数组项还要慢。要理解此中的原因，首先要理解JavaScript 中对象的性质。


Prototypes 原型
JavaScript 中的对象是基于原型的。原型是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原型对象为所有给定类型的对象实例所共享，因此所有实例共享原型对象的成员。

一个对象通过一个内部属性绑定到它的原型。Firefox，Safari，和Chrome 向开发人员开放这一属性，称作__proto__；其他浏览器不允许脚本访问这一属性。任何时候你创建一个内置类型的实例，如Object 或Array，这些实例自动拥有一个Object 作为它们的原型。

因此，对象可以有两种类型的成员：实例成员（也称作“own”成员）和原型成员。实例成员直接存在于实例自身，而原型成员则从对象原型继承。
demo: prototype.htm

此代码中，book 对象有两个实例成员：title 和publisher。注意它并没有定义toString()接口，但是这个接口却被调用了，也没有抛出错误。toString()函数就是一个book 对象继承的原型成员。

处理对象成员的过程与变量处理十分相似。当book.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果book 没有名为toString 的成员，那么就转向搜索原型对象，在那里发现了toString()方法并执行它。通过这种方法，booke 可以访问它的原型所拥有的每个属性或方法。

你可以使用hasOwnProperty()函数确定一个对象是否具有特定名称的实例成员，（它的参数就是成员名称）。要确定对象是否具有某个名称的属性，你可以使用操作符in。
demo: hasOwnProperty.htm

此代码中，hasOwnProperty()传入“title”时返回true，因为title 是一个实例成员。传入“toString”时返回false，因为toString 不在实例之中。如果使用in 操作符检测这两个属性，那么返回都是true，因为它既搜索实例又搜索原型。


Prototype Chains 原型链
对象的原型决定了一个实例的类型。默认情况下，所有对象都是Object 的实例，并继承了所有基本方法，如toString()。你可以用“构造器”创建另外一种类型的原型。
demo: book.htm

Book 构造器用于创建一个新的Book 实例。book1 的原型（__proto__）是Book.prototype，Book.prototype的原型是Object。这就创建了一个原型链，book1 和book2 继承了它们的成员。
demo: Book.docx

注意，两个Book 实例共享同一个原型链。每个实例拥有自己的title 和publisher 属性，但其他成员均继承自原型。当book1.toString()被调用时，搜索工作必须深入原型链才能找到对象成员“toString”。正如你所怀疑的那样，深入原型链越深，搜索的速度就会越慢。图2-11 显示出成员在原型链中所处的深度与访问时间的关系。

虽然使用优化JavaScript 引擎的新式浏览器在此任务中表现良好，但是老的浏览器，特别是Internet Explorer 和Firefox 3.5，每深入原型链一层都会增加性能损失。记住，搜索实例成员的过程比访问直接量或者局部变量负担更重，所以增加遍历原型链的开销正好放大了这种效果。


Nested Members 嵌套成员
由于对象成员可能包含其它成员，例如不太常见的写法window.location.href 这种模式。每遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。

结果并不奇怪，成员嵌套越深，访问速度越慢。location.href 总是快于window.location.href，而后者也要比window.location.href.toString()更快。如果这些属性不是对象的实例属性，那么成员解析还要在每个点上搜索原形链，这将需要更长时间。


Caching Object Member Values 缓存对象成员的值
由于所有这些性能问题与对象成员有关，所以如果可能的话请避免使用它们。更确切地说，你应当小心地，只在必要情况下使用对象成员。例如，没有理由在一个函数中多次读取同一个对象成员的值：
function hasEitherClass(element, className1, className2){
return element.className == className1 || element.className == className2;
}

在此代码中，element.className 被访问了两次。很明显，在这个函数过程中它的值是不会改变的，但仍然引起两次对象成员搜索过程。你可以将它的值存入一个局部变量，消除一次搜索过程。修改如下：
function hasEitherClass(element, className1, className2){
var currentClassName = element.className;
return currentClassName == className1 || currentClassName == className2;
}

一般来说，如果在同一个函数中你要多次读取同一个对象属性，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生难以置信的影响。

在一个函数中，你绝不应该对一个对象成员进行超过一次搜索，除非该值可能改变。


Summary 总结
在JavaScript 中，数据存储位置可以对代码整体性能产生重要影响。有四种数据访问类型：直接量，变量，数组项，对象成员。它们有不同的性能考虑。

直接量和局部变量访问速度非常快，数组项和对象成员需要更长时间。

局部变量比域外变量快，因为它位于作用域链的第一个对象中。变量在作用域链中的位置越深，访问所需的时间就越长。全局变量总是最慢的，因为它们总是位于作用域链的最后一环。

避免使用with 表达式，因为它改变了运行期上下文的作用域链。而且应当小心对待try-catch 表达式的catch子句，因为它具有同样效果。

嵌套对象成员会造成重大性能影响，尽量少用。

一个属性或方法在原形链中的位置越深，访问它的速度就越慢。

一般来说，你可以通过这种方法提高JavaScript 代码的性能：将经常使用的对象成员，数组项，和域外变量存入局部变量中。然后，访问局部变量的速度会快于那些原始变量。

通过使用这些策略，你可以极大地提高那些需要大量JavaScript 代码的网页应用的实际性能。